use sbi_rt::{system_reset, NoReason, Shutdown};
pub fn os_shut_down() -> ! {
    system_reset(Shutdown, NoReason);
    unreachable!()
}

use riscv::register::satp::{self, Mode};

pub fn change_pagetable(paddr: usize) {
    // 1. Read the current Satp value using the module's read() function
    //debug!("paddr: {:x}", paddr);
    let mut satp_val = satp::read(); // This should return a Satp struct instance
    //debug!("satp_cur_val: {:x}", satp_val.bits());
    // 2. Modify its fields using setter methods.
    // These methods are typically generated by the read_write_csr! macro.
    satp_val.set_mode(Mode::Sv39);
    satp_val.set_asid(0);
    satp_val.set_ppn(paddr >> 12);
    //debug!("satp_next_val: {:x}", satp_val.bits());
    // 3. Write the modified Satp value back
    unsafe {
        satp::write(satp_val);
    }
    flush_tlb();
}

pub fn flush_tlb() {
    unsafe {
        riscv::asm::sfence_vma_all();
    }
}


pub fn get_cpu_num() -> usize {
    // TODO: This should be initialized from the device tree at boot time.
    const CPU_NUM: usize = 1;
    CPU_NUM
}

pub fn get_cur_cpu_id() -> usize {
    // riscv::register::mhartid::read()
    0
}

pub fn wait_for_interrupt() {
    unsafe {
        riscv::asm::wfi();
    }
}